### 1. OSI 的七层模型分别是什么？各自的功能是什么？ 

物理层：底层数据传输，如网线，网卡标准。【比特流】

数据链路层：定义数据的基本格式，如何传输，如何标识，如网卡 MAC 地址。【帧】

网络层：定义 IP 地址，定义路由功能，如不同设备的数据转发。【包】

传输层：端到端传输数据的基本功能，如 TCP、UDP。【段】

会话层：控制应用程序之间会话能力，如不同软件数据分发给不同软件。

表示层：数据格式标识，基本压缩加密功能。

应用层：各种应用软件，包括 Web 应用。

总结：

- 网络七层模型是一个标准，而非实现。
- 网络四层模型是一个实现的应用模型。
- 网络四层模型由七层模型简化合并而来。

### 2. 三次握手

刚开始客户端处于 closed 的状态，服务端处于 listen 状态，然后：

第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SEND 状态。

第二次握手：服务端收到客户端的 SYN 报文后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN+1 作为 ACK 值，表示自己已经收到了客户端的 SYN，此时服务端处于 SYN_RCVD 的状态。

第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务端的 ISN+1 作为 ACK的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态。

最后，服务端收到 ACK 报文之后，也处于 established 状态，此时，双方已经建立起了连接。

三次握手的作用：

- 确认双发的接收能力、发送能力是否正常。
- 制定自己的初始化序列号，为后面的可靠传送做准备。

1）ISN 是固定的吗？

三次握手的一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number) , 以便让对方知道接下来接收数据的时候如何按序列号组装数据。

如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

2）什么是半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 

3）SYN-ACK 重传次数的问题

服务端发送完 SYN-ACK 包， 如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s， 2s,，4s,，8s。

4）三次握手过程中可以携带数据吗？

第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。 

 假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。 也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。

 而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。 

### 3. 四次挥手

刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：

第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 

第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。

服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

特别注意：TIME_WAIT 状态，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。

原因是要确保服务端已经收到了 ACK 报文，如果没有收到的话，服务端会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

状态：

LISTEN：侦听来自远方 TCP 端口的连接请求；

SYN-SEND：在发送连接请求后等待匹配的连接请求；

SYN-RECEIVED：在收到和发送一个连接请求后等待对连接请求的确认；

ESTABLISHED：代表一个打开的连接，数据可以传送给用户；

FIN-WAIT-1： 等待远程 TCP 的连接中断请求，或先前的连接中断请求的确认； 

FIN-WAIT-2： 从远程 TCP 等待连接中断请求； 

CLOSE-WAIT： 等待从本地用户发来的连接中断请求； 

CLOSING：等待远程 TCP 对连接中断的确认；

LAST-ACK：等待原来发向远程TCP的连接中断请求的确认； 

TIME-WAIT：等待足够的时间以确保远程 TCP 接收到连接中断请求的确认；

CLOSED：没有任何连接状态；

### 4. TCP 与 UDP 有哪些区别？各自应用场景？

TCP 协议的主要特点：

1. TCP 是面向连接的传输层协议：所谓面向连接就是双方传输数据之前，必须先建立一条通路，例如三次握手就是建立通道的一个过程， 而四次挥手则是结束销毁通道的一个其中过程；
2.  每一条 TCP 连接只能有两个端点（即两个套接字），只能是点对点的；
3.  TCP 提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达； 
4.  TCP 提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存； 
5.  面向字节流。虽然应用程序与 TCP 交互是一次一个大小不等的数据块，但 TCP 把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，  例如，发送方应用程序交给发送方的 TCP10 个数据块，但就受访的TCP可能只用了4个数据块久保收到的字节流交付给上层的应用程序，但字节流完全一样。 

TCP的可靠性原理：

1.  传输信道无差错,保证传输数据正确；
2.  不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据；
   1.  首先，采用三次握手来建立 TCP 连接，四次挥手来释放 TCP 连接，从而保证建立的传输信道是可靠的 ；
   2.  其次，TCP 采用了连续 ARQ 协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制；
   3.  最后，TCP 使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。 

UDP 协议的特点：

1.  UDP 是无连接的传输层协议； 
2.  UDP 使用尽最大努力交付，不保证可靠交付 ；
3.  UDP  是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界； 
4.  UDP 没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率； 
5.  UDP 支持一对一　一对多　多对多的交互通信； 
6.  UDP的首部开销小，只有８字节。

TCP 和 UDP 的区别：

1.  TCP 是可靠传输，UDP 是不可靠传输；
2.  TCP 面向连接，UDP 无连接；
3.  TCP 传输数据有序，UDP 不保证数据的有序性；
4.  TCP 不保存数据边界，UDP 保留数据边界；
5.  TCP 传输速度相对 UDP 较慢；
6.  TCP 有流量控制和拥塞控制，UDP 没有；
7.  TCP 是重量级协议，UDP 是轻量级协议；
8.  TCP 首部较长20字节，UDP 首部较短８字节；

基于 TCP 和 UDP 的常用协议：

HTTP、HTTPS、FTP、TELNET、SMTP（简单邮件传输协议）基于可靠的 TCP 协议。

DNS、DHCP、TFTP、SNMP（简单网络管理协议）、RIP基于不可靠的 UDP 协议。

TCP 和 UDP 的应用场景：

TCP 应用场景：效率要求较低，但对准确性要求相对较高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有 UDP 高。举几个例子：文件传输、接收邮件、远程登陆。

UDP 应用场景：效率要求相对较高，对准确性要求相对较低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信。

### 5. HTTP 1.0、1.1、2.0 各个版本的区别

HTTP/1.0

1996年5月，HTTP/1.0版本发布，为了提高系统的效率，HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

这种方式就好像我们打电话的时候，只能说一件事儿一样，说完之后就要挂断，想要说另外一件事儿的时候就要重新拨打电话。

 HTTP/1.0中浏览器与服务器只保持短暂的连接，连接无法复用。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。 

我们知道TCP连接的建立需要三次握手，是很耗费时间的一个过程。所以，HTTP/1.0版本的性能比较差。

补充： HTTP1.0 其实也可以强制开启长链接，例如接受`Connection: keep-alive` 这个字段，但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 

HTTP/1.1

为了解决HTTP/1.0存在的缺陷，HTTP/1.1于1999年诞生。相比较于HTTP/1.0来说，最主要的改进就是引入了持久连接。所谓的持久连接即TCP连接默认不关闭，可以被多个请求复用。

由于之前打一次电话只能说一件事儿，效率很低。后来人们提出一种想法，就是电话打完之后，先不直接挂断，而是持续一小段时间，这一小段时间内，如果还有事情沟通可以再次进行沟通。 

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。

HTTP/1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 

有了持久连接和管道，大大的提升了HTTP的效率。但是服务端还是顺序执行的，效率还有提升的空间。

HTTP/2

HTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 发布后的首个更新，主要基于 SPDY 协议。 

HTTP/2 为了解决HTTP/1.1中仍然存在的效率问题，HTTP/2 采用了多路复用。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP/2进行了二进制分帧，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。

也就是说，老板可以同时下达多个命令，员工也可以收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。A请求的两部分响应在组合到一起发给老板。 

而这个负责拆分、组装请求和二进制帧的一层就叫做二进制分帧层。

除此之外，还有一些其他的优化，比如做Header压缩、服务端推送等。

Header压缩就是压缩老板和员工之间的对话。

服务端推送就是员工事先把一些老板可能询问的事情提现发送到老板的手机（缓存）上。这样老板想要知道的时候就可以直接读取短信（缓存）了。

目前，主流的HTTP协议还是HTTP/1.1 和 HTTP/2。并且各大网站的HTTP/2的使用率也在逐年增加。

### 6. 在交互过程中如果数据传送完了，还不想断开连接怎么办？怎么维持？

在HTTP中响应体的connection字段指定为keep-alive：

```
connection:keep-alive
```

### 7. HTTP 如何实现长连接？在什么时候会超时？

通过在头部（请求头和响应头）设置connection:keep-alive，HTTP/1.0协议支持，但是默认关闭，从HTTP/1.1协议以后，连接默认都是长连接。

HTTP一般会有httpd守护线程，里面可以设置keep-alive timeout，当tcp连接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间。

TCP的keep-alive包含三个参数，支持在系统内核的net.ipv4里面设置：当TCP连接以后，闲置了tcp_keepalive_time，则会发生侦测包，如果没有收到对方的ACK，那么会每隔tcp_keepalive_intvl再发一次，直到发送了tcp_keepalive_probes，就会丢弃该连接。

（1）tcp_keepalive_intvl = 15

（2）tcp_keepalive_probes = 5

（3）tcp_keepalive_time = 1800

实际上，HTTP没有长短连接，只有TCP有，TCP长连接可以复用一个TCP连接来发起多次HTTP请求，这样可以减少资源消耗。

### 8. TCP如何保证有效传输以及拥塞控制原理

TCP是面向连接的、可靠的、传输层通信协议。

可靠体现在：有状态、可控制。

- 有状态是指TCP会确认发送了哪些报文，接收方收到了哪些报文，哪些没收到，保证数据包按序到达，不允许有差错。
- 可控制是指如果出现丢包或者网络状况不佳，则会调整自己的行为，减少发送的速度或重发。

所以上面能保证数据包的有效传输。

**拥塞控制原理：**

原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了。

主要有三种方法：

- 慢启动阈值+拥塞避免
- 快速重传
- 快速恢复

**慢启动阈值+拥塞避免**

对于拥塞控制，TCP主要维护两个核心状态：

- 拥塞窗口
- 慢启动阈值

在发送端使用拥塞窗口来控制发送窗口的大小。

然后采用一种比较保守的慢启动算法来慢慢适应这个网络，在开始传输的一段时间，发送端和接收端会首先通过三次握手建立连接，确定各自接收窗口的大小，然后初始化双方的拥塞窗口，接着每经过一轮TRR（收发时延），拥塞窗口大小翻倍，直到达到慢启动阈值。

然后开始进行拥塞避免，拥塞避免具体的做法就是之前每一轮RTT，拥塞窗口翻倍，现在每一轮加一个。

**快速重传**

在TCP传输过程中，如果发生了丢包，接收端就会发送之前重复ACK，比如第5个包丢了，6、7到达，然后接收端会为6、7发送第四个包的ACK，这个时候发送端收到了2个重复的ACK，意识到丢包了，就会马上进行重传，而不用得到RTO（（超时重传时间）。

选择性重传：报文首部可选性中加入SACK属性，通过left edge和right edge标志哪些包到了，然后重传没到的包。

**快速恢复**

如果发送端收到了3个重复的ACK，发现丢包，觉得现在网络状况已经到了拥塞状态，那么就会进入到快速恢复阶段：

- 会将拥塞阈值降低为拥塞窗口的一半
- 然后拥塞窗口大小变为拥塞阈值
- 接着拥塞窗口再进行线性增加，以适应网络状况

### 9. IPV4地址不够如何解决

目前主要有以下两种方式：

- NAT协议（Network Address Translation）
- IPV6

### 10. IP地址和MAC地址有什么区别？

简单来说，IP地址主要用来网络寻址用的，而MAC地址则是身份的唯一象征，但是MAC地址不具备寻址的功能。

### 11. TCP最大连接数限制

**如何标识一个TCP连接**

在确定最大连接数之前，先来看看系统如何标识一个tcp连接。

系统用一个四元组来唯一标识一个TCP连接：

```
{
	local_ip, 
	local_port,
	remote_ip,
	remote_port
}
```

**client最大TCP连接数**

client每次发起TCP连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他TCP连接共享。 TCP端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大TCP连接数为65535，这些连接可以连到不同的server ip。  

**server最大TCP连接数**

server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，  因此server端TCP连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大TCP连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，  最大TCP连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大TCP连接数约为2的48次方。 

**实际的TCP连接数**

上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发TCP连接数远不能达到理论上限。  在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个TCP连接都要占用一定内存，每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。在默认2.6内核配置下，经过试验，每个socket占用内存在15~20k之间。 

 影响一个socket占用内存的参数包括： rmem_max、wmem_max、tcp_rmem、tcp_wmem、tcp_mem、grep skbuff /proc/slabinfo。

 对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万是没问题的，国外Urban Airship公司在产品环境中已做到 50 万并发 。

在实际应用中，对大规模网络应用，还需要考虑C10K问题。 

### 12. GET请求中URL编码的意义

避免歧义。

考虑这样一个场景：name1=va&lue=e1，其中va&lue=e1是值，但是服务端可能会将其解析成两个键值对，这样就产生了歧义。

解决方案就是对参数进行URL编码。

### 13. 网络五层模型⭐⭐⭐⭐⭐

物理层

数据链路层：以太网协议→帧，MAC地址、ARP

网络层：IP协议、ARP协议、DNS

传输层：PORT、TCP\UDP

应用层

### 14. HTTP和HTTPS的区别

HTTP协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；

HTTPS是身披SSL（Secure Socket Layer）外壳的HTTP，运行在SSL之上，SSL运行在TCP之上，是添加了加密和认证机制的HTTP。

不同：

1. 端口不同，HTTP与HTTPS使用不同的连接方式，用的端口也不同，前者是80，后者是443；
2. 资源消耗不同，HTTPS通信由于加密解密消耗更多的资源；
3. 开销不同，HTTPS需要证书，而证书一般需要向认证机构购买。

HTTPS的加密机制是一种共享密钥加密并用的混合加密机制。

### 15. 对称加密和非对称加密的区别

对称密钥加密是指加密和解密使用的是同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发送给对方。

而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接受到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的密钥，所以可以保证安全性，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

### 16. 什么是SQL注入？举个例子

SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

**SQL注入攻击的总体思路**

（1）寻找SQL注入的位置

（2）判断服务器类型和后台数据库类型

（3）针对不同的服务器和数据库特点进行SQL注入攻击

**SQL注入攻击实例**

比如在登录界面，要求输入用户名密码，可以这样输入避免账户登录：

```
username="or 1 = 1"
password=""
```

**应对方法**

（1）参数绑定：使用预编译手段，绑定参数是最好的防止SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL参数而不是SQL命令被执行。

（2）使用正则表达式过滤传入的参数

### 17. 谈一谈XSS攻击？举个例子

XSS是一种经常出现在Web应用中的计算机安全漏洞，与SQL注入一起成为Web中最主流的攻击方式。

XSS是指恶意攻击者利用网站没有对用户提交的数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到Web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或对访问者进行病毒侵害的一种攻击方式。

**修复漏洞方针**

漏洞产生的根本原因：太相信用户提交的数据。

具体方案包括：

（1）将重要的cookie标记为http only，这样js就无法获取到cookie，能够有效防止XSS攻击。

（2）表单数据类型检测。

（3）对数据进行HTML Encode处理。

（4）过滤或移除特殊HTML标签，过滤JS事件标签。

### 18. 简单说一下每一层对应的网络协议有哪些？

**应用层**：HTTP（超文本传输协议）、TFP（文件传输协议）、SMTP（简单邮件传输协议）、SSH（安全外壳协议）、DHCP（动态主机配置协议）、TELNET（远程登录协议）

**传输层**：TCP（传输控制协议）、UDP（用户数据报文协议）

**网络层**：IP（网际协议）、ARP（地址转换协议）、RARP（反向地址转换协议）、ICMP（Internet 控制报文协议）、IGMP（Internet 组管理协议）、RIP（路由信息协议）、OSPF（分布式链路状态协议）、BGP（边界网关协议）

**数据链路层**：ARQ（自动重传请求协议）、CSMA/CD（停止等待协议）、PPP（点对点协议）

**物理层**：中继器、集线器、网线、HUB

### 19. ARP协议的工作原理

网络层的ARP协议完成了IP地址与物理地址的映射。

首先，每台主机都会在自己的ARP缓冲区建立一个ARP列表，以表示IP地址和MAC地址的对应关系。

当源主机需要将一个数据包发送到目的主机时，会首先检查自己的ARP列表中是否存在该IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址，如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。

此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址，网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致，如果不相同就忽略此数据包，如果相同，该主机首先会将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址，源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。

如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

### 20. TCP的主要特点是什么

TCP

S是面向连接的。

每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。

TCP提供可靠交付的服务，通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。

TCP提供全双工通信，TCP允许通信双方的应用进程在任何时候都能发送数据，TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据。

面向字节流，TCP中的流指的是流入进程或从进程流出的字节序列。面向字节流的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来数据仅仅看成是一连串无结构的字节流。

### 21. UDP的主要特点是什么

UDP是无连接的。

UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态。

UDP是面向报文的。

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。

UDP支持一对一、一对多、多对多的交互通信。

UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

### 22. TCP和UDP分别对应的常见应用层协议有哪些？

**TCP对应的应用层协议**

FTP：定义了文件传输协议，使用21端口。

Telnet：远程登录协议，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。

SMTP：简单邮件传送协议，用于发送邮件，使用25端口。

POP3：它和SMTP对应，POP3用于接收邮件，通常情况下POP3协议使用110端口。

HTTP：从Web服务器传输超文本到本地浏览器的传送协议。

**UDP对应的应用层协议**

DNS：用于域名解析服务，将域名地址转换为IP地址，DNS使用53号端口号。

SNMP：简单网络管理协议，使用161号端口号，用来管理网络设备，由于网络设备很多，无连接的服务就体现出其优势。

TFTP（Trival File Transfer Protocal）：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

### 23. 为什么TIME-WAIT状态必须等待2MSL的时间呢？

（1）为了保证A发送的最后一个ACK报文段能够到达B，这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对方已经发送的FIN+ACK报文段的确认，B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内（超时+1MSL）收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器，最后A和B都正常进入到CLOSED状态，如果A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段，这样，B就无法按照正常步骤进入CLOSED状态。

（2）防止已失效的连接请求报文段出现在本连接中，A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都在网络中消失，这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

### 24. 保活计时器的作用？

除时间等待计时器外，TCP还有一个保活计时器（keepalive timer）。

设想这样的场景：A与B建立了TCP连接，A崩了，应当有措施让B不再等待下去。

服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两个小时都没有收到客户端的数据，服务端就会发送一个探测报文段，以后每隔75秒发送一次，若连续发送10个探测报文段后仍然无客户端响应，服务端就认为客户端出现了故障，接着就关闭这个连接。

### 25. TCP协议是如何保证可靠传输的？

（1）数据包校验：目的是检测数据在传输过程中的任何变化，若检验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据。

（2）对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序，TCP将对失序数据进行重新排序，然后才交给应用层。

（3）丢弃重复数据

（4）应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常将推迟几分之一秒。

（5）超时重发

（6）流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的连接端只允许另一端发送接收端缓冲区能接纳的数据，这可以防止较快主机致使较慢主机缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

### 26. 谈谈你对停止等待协议的理解























































