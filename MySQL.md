### 1. MySQL架构

![img](https://img-blog.csdnimg.cn/20190109110912557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bjd2wxMjA2,size_16,color_FFFFFF,t_70)

大体来说，MySQL可以分为**Server层**和**存储引擎**两部分。

**Server层**包括：连接器、查询缓存、分析器、优化器、执行器等，涵盖了MySQL的大多数核心服务功能，以及所有的内置函数（如：日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图等等。

**存储引擎层**负责：数据的存储和提取。其架构是插件式的，支持InnoDB、MyISAM等多个存储引擎。从 MySQL5.5.5版本开始默认的是InnoDB，但是在建表时可以通过engine = MyISAM来指定存储引擎。不同存储引擎的表数据存取方式不同，支持的功能也不同。

不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。

### 2. 一条SQL语句在数据库框架中的执行流程？

（1）应用程序把查询SQL语句发送给服务器端执行；

（2）查询缓存，如果查询缓存是打开的，服务器在接收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相对应的查询数据，如果存在，则直接返回给客户端。只有缓存不存在时，才会进行下面的操作；

（3）查询优化处理，生成执行计划。这个阶段主要包括解析SQL、预处理、优化SQL执行计划；

（4）MySQL根据相应的执行计划完成整个查询；

（5）将查询结果返回给客户端。

详细过程：https://blog.csdn.net/pcwl1206/article/details/86137408

### 3. 数据库的三范式是什么？

第一范式：强调列的原子性，即数据库表的每一项都是不可分割的原子数据项；

第二范式：要求实体的属性完全依赖于主关键字，所谓完全依赖是指不能存在仅依赖主关键字一部分的属性；

第三范式：任何非主属性不依赖于其他非主属性。

### 4. char和varchar的区别？

char(n)：固定长度类型，比如：char(10)，当你输入”abc”三个字符的时候，它们占的空间还是10个字节，其他7个是空字节。char优点：效率高；缺点：占用空间；适用场景：存储密码的md5值，固定长度的，使用char非常合适。

varchar(n)：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。

所以，从空间上考虑varcahr比较合适；从效率上考虑char比较合适，二者使用需要权衡。

### 5. varchar(10)和varchar(20)的区别？

varchar(10)中10的涵义最多存放10个字符，varchar(10)和varchar(20)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度。

### 6. 谈谈你对索引的理解

索引的出现是为了提高数据的查询效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。

同样索引也会带来很多负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。

**建立索引的原则：**

（1）在最频繁使用的、用以缩小查询范围的字段上建立索引；

（2）在频繁使用的、需要排序的字段上建立索引。

**不适合建立索引的情况：**

（1）对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引；

（2）对于一些特殊的数据类型，不宜建立索引，比如：文本字段（text）等。

### 7. 索引的底层使用的是什么数据结构？

索引的数据结构和具体存储引擎的实现有关,，在MySQL中使用较多的索引有Hash索引、B+树索引等。而我们经常使用的InnoDB存储引擎的默认索引实现为B+树索引。

### 8.谈谈你对B+树的理解

（1）B+ 树是基于 B 树和叶子节点顺序访问指针进行实现，它具有 B 树的平衡性，并且通过顺序访问指针来提高区间查询的性能。

（2）在 B+ 树中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。

（3）进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

（4）插入、删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。







