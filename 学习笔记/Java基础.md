### 1. 解释下什么是面向对象？面向对象和面向过程的区别？

### 2. 面向对象的三大特性

**封装**：

**继承**：

**多态**：分为**编译时多态（方法重载）**和**运行时多态（方法重写）**。实现多态需要做两件事：一是子类继承父类并重写父类中的方法，二是用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为。

补充：子类拥有父类对象的所有属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。因为在**一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象**。

### 3. JDK、JRE、JVM三者之间的关系

JDK（Java Development Kit）：是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中开发工具包括：编译工具（javac.exe）、打包工具（jar.exe）等。

JRE（Java Runtime Environment）：包括了Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如包装类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包。如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。

JVM：Java虚拟机，是整个Java实现跨平台的最核心的部分，能够运行以Java语言写的软件程序，所有的Java程序会首先被编译为.class文件，这种类文件可以在虚拟机上执行。

### 4. 重载与重写的区别？

重载：编译时多态，是一个类中多态性的一种表现，指同一个类中不同的函数使用相同的函数名，但是函数的参数个数或者类型不同。可以有不同的返回类型，可以有不同的访问修饰符，可以抛出不同的异常。调用的时候根据函数的参数来区别不同的函数。

重写：运行时多态，是父类与子类之间的多态性，是子类对父类函数的重新实现。函数名和参数与父类一样，子类与父类函数体内容不同。子类返回的类型必须与父类保持一致，子类方法访问修饰的限制一定要大于父类方法的访问修饰（public > protected > default > private），子类重写方法一定不能抛出新的检查异常或者比较父类方法声明更加宽泛的检查型异常。

### 5. Java中是否可以重写一个private方法或static方法？⭐

Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关。

Java中也不可以覆盖private方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。

补充：静态方法补充：静态方法可以被继承，但是不能被重写，如果父类和子类中存在同样名称和参数的静态方法，那么该子类的方法会把原来继承过来的父类的方法隐藏，而不是重写。通俗的讲就是父类的方法和子类的方法是两个没有关系的方法，具体调用哪一个方法是看是哪个对象的引用；这种父子类方法也不在存在多态的性质。

再补充：关于Java中为什么不能重写static方法解释：

JVM提供了5条方法调用字节码指令，分别如下所示，前面两种方法都可以在类解析阶段确定唯一的调用版本，这些方法称之为非虚方法，与之对应的就是虚方法：

- invokestatic：调用静态方法
- invokespecial：调用实例构造器方法、私有方法和父类方法
- invokevirtual：调用所有的虚方法
- invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象

### 6. 重写：为什么通过父类引用调用方法时会调用子类中定义的方法呢？

很多人是这样理解的：当我们在子类中重写方法时，会将父类中定义的方法覆盖掉，也就是说当执行People p = new Man();时，只会将子类中定义的方法加载到方法区。

但是，事实并非如此！

创建对象时，父类与子类中定义的方法会依次加载到方法区中。

那么父类的引用是如何定位到子类中重写的方法呢？

实际上，对于不同类型的方法，字节码指令集中设计了不同的调用指令，不同的指令有不同的实现逻辑。Java中默认的方法都是虚方法，也就是可以重写的方法。虚方法的调用指令是invokevirtual。

invokevirtual指令的运行时解析过程大致如下：

（1）找到引用所指向的对象的实际类型。 // 对于People p = new Man(); 其静态类型为People，实际类型为Man。

（2）如果在实际类型中找到名称相符的方法，则返回该方法的直接引用，接着调用该方法。

（3）如果没找到，按照继承关系从上往下在其各个父类中进行第二步。

值得注意的是，对于运行时多态，其静态类型在编译期就已经确定，实际类型在编译期无法确定，运行时才能确定。

### 7. 构造方法有哪些特性

（1）名字与类名相同；

（2）没有返回值，但不能用void声明构造函数；

（3）成类的对象时自动执行，无需调用。

### 8. 在Java中定义一个不做事且没有参数的构造方法有什么作用？

### 9. Java中创建对象的几种方式？

（1）使用new关键字

（2）使用Class类的newInstance方法，该方法调用无参的构造器创建对象（反射）

（3）使用clone()方法

（4）反序列化，比如调用ObjectInputStream类的readObject()方法

### 10. 如何实现对象的克隆？

（1）实现Cloneable接口并重写Object类中的clone()方法

（2）实现Serialize接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆

### 11. 深克隆和浅克隆的区别？

（1）浅克隆：拷贝对象和原始对象的引用类型引用同一个对象，浅克隆只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。

（2）深克隆： 拷贝对象和原始对象的引用类型引用不同对象。深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变 。

补充：

 深克隆的实现就是在引用类型所在的类实现Cloneable接口，并使用public访问修饰符重写clone方法。 

 Java中定义的clone没有深浅之分，都是统一的调用Object的clone方法。为什么会有深克隆的概念？是由于我们在实现的过程中刻意的嵌套了clone方法的调用。也就是说深克隆就是在需要克隆的对象类型的类中重新实现克隆方法clone()。 

### 12. 抽象类和接口有什么区别？

（1）抽象类可以定义构造函数，接口不能定义构造函数

（2）抽象类可以有抽象方法和具体方法，接口只有抽象方法（public abstract）

（3）抽象类中的成员权限可以是public、默认、protected（抽象类中抽象方法就是为了重写，所以不能被private修饰），接口中只能是public（方法默认：public abstract、成员变量默认：public static）

（4）抽象类中可以包含静态方法，接口中不可以包含静态方法

补充：JDK1.8中的改变

（1）在JDK1.8中，允许在接口中包含带有具体实现的方法，使用default修饰，这类方法就是默认方法：应用场景：举个例子： 接口早就写好了，后面因为各种业务问题，避免不了要修改接口。在Java8之前，比如要在一个接口中添加一个抽象方法，那所有的接口实现类都要去实现这个方法，不然就会编译错误，而某些实现类根本就不需要实现这个方法也被迫要写一个空实现，改动会非常大。所以，接口默认方法就是为了解决这个问题，只要在一个接口添加了一个默认方法，所有的实现类就自动继承，不需要改动任何实现类，也不会影响业务。另外，接口默认方法可以被接口实现类重写。

（2）抽象类中可以包含静态方法，在JDK1.8之前，接口不能包含静态方法，JDK1.8以后可以。 之前不能包含是因为，接口不可以实现方法，只可以定义方法，所以不能使用静态方法（因为静态方法必须实现）。现在可以包含了，只能直接用接口调用静态方法。JDK1.8仍然不可以包含静态代码块 

### 13. 静态变量和实例变量的区别？

静态变量：是被static修饰的变量，也称为类变量，它属于类，因此不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；静态变量可以实现让多个对象共享内存。

实例变量：属于某一实例，需要先创建对象，然后通过对象才能访问到它。

### 14. short s1 = 1; s1 = s1 + 1; → 有什么错？short s1 = 1; s1 += 1; → 有没有错？

对于 short s1 = 1; s1 = s1 + 1; 来说，在 s1 + 1 运算时会自动提升表达式的类型为 int ，那么将int型值赋值给short型变量，s1会出现类型转换错误。 

对于 short s1 = 1; s1 += 1; 来说，+=是 Java 语言规定的运算符，Java编译器会对它进行特殊处理，因此可以正确编译。 

### 15. Integer和int的区别？

### 16. 装箱和拆箱的区别？

### 17. switch语句能否作用在byte上，能否作用在long上，能否作用在String上？

switch(expr)中，expr只能是一个整数表达式或枚举常量。整数表达式可以是int基本类型数据或Integer包装类型。由于byte、short、char都可以隐式转换为int，所以，这些类型以及这些类型的包装类型也都是可以转换的。而long和String类型都不符合switch的语法规定，并且不能被隐式的转换为int类型，所以不可以。

注意，JDK1.7之后，switch可以作用在String上。

### 18. final、finally、finalize的区别

### 19. ==和equals的区别

==：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址是否相等。

equals：用来比较两个对象的内容是否相等，默认比较的是引用类型的变量所指向的对象的地址。

### 20. 两个对象的hashCode()相同，则equals()也一定为true吗？

比如：哈希冲突

### 21. 为什么重写equals()就一定要重写hashCode()？

这个问题应该是有个前提，就是你需要用到HashMap、HashSet等集合，用不到哈希表的话，其实仅仅重写equals()也可以。

对于对象集合的判重，如果一个集合含有10000个对象实例，仅仅使用equals()方法的话，那么对于一个对象判重就需要比较10000次，随着集合规模的增大，时间开销是很大的。 

但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在定位到大概存储位置后，后续比较过程中，如果两个对象的hashCode不相同，也不再需要调用equals()方法，从而大大减少了equals()比较次数。 

所以从程序实现原理上来讲的话，既需要equals()方法，也需要hashCode()方法。那么既然重写了equals()，那么也要重写hashCode()方法，以保证两者之间的配合关系。 

hashCode()与equals()的相关规定：

（1）如果两个对象相等，则hashCode一定也是相同的

（2）两个对象相等，对两个对象分别调用equals方法都返回true

（3） 两个对象有相同的hashCode值，它们也不一定是相等的

（4） 因此，equals方法被覆盖过，则hashCode方法也必须被覆盖 

（5） hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。 

### 22. &和&&的区别

&和&&都是表示与的逻辑运算符，&&会短路而&不会，此外，&两边表达式不是boolean类型，就表示按位与操作。

### 23. Java中参数传递是值传递还是引用传递？

值传递

### 24. Java序列化

对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序。从字节流创建对象的相反的过程称为反序列化。 

而创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化。序列化是为了解决在对象流进行读写操作时所引发的问题。 

序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，只是用于标注该对象是可被序列化的。 然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObject(Object obj)方法可以将参数为obj的对象写出，要恢复的话则使用输入流。 

### 25. 什么情况下需要序列化

（1） 当你想把的内存中的对象状态保存到一个文件中或者数据库中时候 

（2）当你想用套接字在网络上传送对象的时候 

（3）当你想通过RMI（Remote Method Invoke）传输对象的时候 

### 26. Java泛型是如何工作的，什么是类型擦除？

泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。这样做的目的是能确保和Java5之前的版本开发二进制类库进行兼容。

### 27. 什么是泛型中的限定通配符和非限定通配符

限定通配符对类型进行了限制，有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面< ? >表示了非限定通配符，因为< ? >可以用任意类型来替代。 

### 28. Java中的反射是什么意思？有哪些应用场景

每个类都有一个Class对象，包含了与类有关的信息，当编译一个新类时，会产生一个同名的.class文件，该文件内容保存着Class对象。类加载相当于Class对象的加载，类在第一次使用时才会动态加载到JVM中。也可以使用Class.forName()这种方式来控制类的加载，该方法会返回一个Class对象。

反射可以提供运行时的类信息， 并且这个类可以在运行时才加载进来，甚至在编译时期该类的.class不存在也可以加载进来。Class和java.lang.reflect一起对反射提供了支持，java.lang.reflect类库主要包含了以下三个类： 

（1）Field：

（2）Method：

（3）Constructor：

应用举例：工厂模式、使用反射机制，根据全限定类名获得某个类的Class实例

### 29. 反射的优缺点

### 30. Java中的动态代理是什么？有哪些应用？

动态代理：当想要实现给某个接口或类中的方法，加一些额外的处理，比如加日志，加事务等， 可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新功能。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。 

动态代理的应用：Spring AOP、加事务、加权限、加日志等。

### 31. 怎么实现动态代理？⭐⭐⭐

JDK与CGlib

### 32. static关键字的作用

（1）静态变量： 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。

（2）静态方法： 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法，方法中不能有this和super关键字。

（3）静态语句块： 静态语句块在类初始化时运行一次。

（4）静态内部类： 非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。

（5）初始化顺序： 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

初始化顺序补充：

1. 父类（静态变量、静态语句块）
2. 子类（静态变量、静态语句块）
3. 父类（实例变量、普通语句块）
4. 父类（构造函数）
5. 子类（实例变量、普通语句块）
6. 子类（构造函数）

### 33. super关键字的作用

访问父类构造函数、访问父类成员

注意：this(...)和super(...)不能同时出现在一个构造函数里面。

java规定，在执行构造函数之前必须执行父类的构造函数，直到这个类是java.lang.Object类的构造函数。

然而函数的入口是子类构造函数，因此任何构造函数第一句,必须是执行父类构造函数，如果没有添加super关键字，那么编译器会为该构造函数第一句添加一个super()语句(你可以这么理解，当然编译以后并不是这样)。如果有super关键字显示的调用父类构造函数，就是用指定的那个父类构造函数，否则使用默认的无参构造函数。

也有一种情况例外，就是存在this()，调用本类其它构造函数，但是按照递归调用，最终还是会调用父类构造函数;如果this()和super()都存在,那么就会出现:初始化父类两次的不安全操作，因为当super()和this()同时出现的时候，在调用完了super()之后 还会执行this()，而this()中又会自动调用super(),这就造成了调用两次super()的结果。

如果你继承的父类没有无参数构造函数，那么你这个类第一句必须显示的调用super关键字,来调用父类对应的有参构造函数，否则不能通过编译。

### 34. 字节和字符的区别

字节是存储容量的基本单位。

字符是数字、字母、汉字以及其他语言的各种符号。

1字节 = 8 个二进制单位，一个字符由一个字节或多个字节的二进制单位组成。

### 35. String为什么要设计为不可变类

在Java中将String设计成不可变是综合考虑到各种因素的结果，主要的原因主要有以下三点：

（1）字符串常量池的需要：字符串常量池是Java堆内存中一个特殊的存储区域，当创建一个String对象时，加入此字符串值已经存在于常量池，则不会创建一个新的对象，而是引用已经存在的对象。

（2）允许String对象缓存HashCode：Java中String对象的哈希码被频繁地使用，比如在HashMap等容器中。字符串不变性保证了hash码的唯一性，因此可以放心地进行缓存。这也是一种性能优化手段，意味着不必每次都去计算新的哈希码。

（3）String被许多的Java类库用来当作参数，例如：网络连接地址URL、文件路径path、还有反射机制所需要的String参数等，假若String不是固定不变的，将会引起各种安全隐患。

### 36. String、StringBuilder、StringBuffer的区别？

String：用于字符串操作，属于不可变类；String不是基本数据类型，是引用类型，底层用char数组实现的。

StringBuilder：与StringBuffer类似，都是字符串缓冲区，但线程不安全。

StringBuffer：与StringBuilder类似，线程安全。

### 37. String字符串修改实现的原理

当用String类型来对字符串进行修改时，其实现方法是首先创建一个StringBuilder，其次调用 StringBuilder 的append()方法，最后调用StringBuilder的toString()方法把结果返回。 

### 38. String str = "i"与String str = new String("i")区别

重点：常量池

### 39. final修饰StringBuffer后还可以append吗？

可以，引用不变而已，但是这个对象内部的属性是可以变化的。

### 40. Java的IO流的分类？说出几个你熟悉的实现

按功能来分：输入流、输出流

按类型来分：字节流、字符流

### 41. 字节流和字符流的区别

### 42. BIO、NIO、AIO的区别

BIO：同步阻塞

NIO：同步非阻塞

AIO：异步非阻塞

### 43. Java语言为什么把String类型设计成不可变

第一：在Java程序中String类型是使用最多的，这就牵扯到大量的增删改查，每次增删改查之前其实JVM需要检查一下这个String对象的安全性，就是通过hashCode()，当设计成不可变对象时，就保证了每次增删改查的hashCode()的唯一性，也就可以放心的操作。

第二：网络链接地址URL，文件路径path，通常情况下都是以String类型保存，假若String不是固定不变的，将会引起各种安全隐患。就好比我们的密码不能以String的类型保存，如果你将密码以明文的形式保存成字符串，那么它将一直留在内存中，直到垃圾收集器把它清除。而由于字符串被放在字符串缓冲池中以方便重复使用，所以它就可能在内存中被保留很长时间，而这将导致安全隐患。

第三：字符串值是被保留在常量池中的，也就是说假若字符串对象允许改变,那么将会导致各种逻辑错误。