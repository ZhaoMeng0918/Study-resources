### 1. OSI 的七层模型分别是什么？各自的功能是什么？ ⭐

物理层：底层数据传输，如网线，网卡标准。【比特流】

数据链路层：① 定义数据的基本格式，如何传输，如何标识，如网卡 MAC 地址。【帧】

​                       ② 负责数据的封帧和差错检测，以及 MAC 寻址。

网络层：① 定义 IP 地址，定义路由功能，如不同设备的数据转发。【包】

​               ② 负责数据的路由、转发、分⽚。

传输层：端到端传输数据的基本功能，如 TCP、UDP。【段】

会话层：控制应用程序之间会话能力，如不同软件数据分发给不同软件。

表示层：数据格式标识，基本压缩加密功能。

应用层：各种应用软件，包括 Web 应用。

总结：

- 网络七层模型是一个标准，而非实现。
- 网络四层模型是一个实现的应用模型。
- 网络四层模型由七层模型简化合并而来。

### 2. 三次握手⭐⭐⭐⭐⭐

刚开始客户端处于 closed 的状态，服务端处于 listen 状态，然后：

第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SEND 状态。

第二次握手：服务端收到客户端的 SYN 报文后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN+1 作为 ACK 值，表示自己已经收到了客户端的 SYN，此时服务端处于 SYN_RCVD 的状态。

第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务端的 ISN+1 作为 ACK的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态。

最后，服务端收到 ACK 报文之后，也处于 established 状态，此时，双方已经建立起了连接。

三次握手的作用：

- 确认双发的接收能力、发送能力是否正常。
- 制定自己的初始化序列号，为后面的可靠传送做准备。

（**补充）三次握手的原因：**

- 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；
- 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。

关键词：全双工、需要双方确认序列号



？？？防止已失效的连接请求又传送到服务器端，因而产生错误？？？

第一种：失效连接求情发送到服务端，两次握手导致服务端资源浪费

第二种：失效连接请求发送到服务端，服务端开启连接，此时客户端发送请求，序列号不对，服务端拒绝并丢弃请求包。





1）ISN 是固定的吗？

三次握手的一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number) , 以便让对方知道接下来接收数据的时候如何按序列号组装数据。

如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

2）什么是半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 

3）SYN-ACK 重传次数的问题

服务端发送完 SYN-ACK 包， 如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s， 2s,，4s,，8s。

4）三次握手过程中可以携带数据吗？

第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。 

 假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。 也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。

 而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。 

### 3. 四次挥手⭐⭐⭐⭐⭐

刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：

第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 

第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。

服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

特别注意：TIME_WAIT 状态，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。

原因是要确保服务端已经收到了 ACK 报文，如果没有收到的话，服务端会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

状态：

LISTEN：侦听来自远方 TCP 端口的连接请求；

SYN-SEND：在发送连接请求后等待匹配的连接请求；

SYN-RECEIVED：在收到和发送一个连接请求后等待对连接请求的确认；

ESTABLISHED：代表一个打开的连接，数据可以传送给用户；

FIN-WAIT-1： 等待远程 TCP 的连接中断请求，或先前的连接中断请求的确认； 

FIN-WAIT-2： 从远程 TCP 等待连接中断请求； 

CLOSE-WAIT： 等待从本地用户发来的连接中断请求； 

CLOSING：等待远程 TCP 对连接中断的确认；

LAST-ACK：等待原来发向远程TCP的连接中断请求的确认； 

TIME-WAIT：等待足够的时间以确保远程 TCP 接收到连接中断请求的确认；

CLOSED：没有任何连接状态；

### 4. TCP 与 UDP 有哪些区别？各自应用场景？

TCP 协议的主要特点：

1. TCP 是面向连接的传输层协议：所谓面向连接就是双方传输数据之前，必须先建立一条通路，例如三次握手就是建立通道的一个过程， 而四次挥手则是结束销毁通道的一个其中过程；
2.  每一条 TCP 连接只能有两个端点（即两个套接字），只能是点对点的；
3.  TCP 提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达； 
4.  TCP 提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存； 
5.  面向字节流。虽然应用程序与 TCP 交互是一次一个大小不等的数据块，但 TCP 把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，  例如，发送方应用程序交给发送方的 TCP10 个数据块，但就受访的TCP可能只用了4个数据块久保收到的字节流交付给上层的应用程序，但字节流完全一样。 

TCP的可靠性原理：

1.  传输信道无差错,保证传输数据正确；
2.  不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据；
   1.  首先，采用三次握手来建立 TCP 连接，四次挥手来释放 TCP 连接，从而保证建立的传输信道是可靠的 ；
   2.  其次，TCP 采用了连续 ARQ 协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制；
   3.  最后，TCP 使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。 

UDP 协议的特点：

1.  UDP 是无连接的传输层协议； 
2.  UDP 使用尽最大努力交付，不保证可靠交付 ；
3.  UDP  是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界； 
4.  UDP 没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率； 
5.  UDP 支持一对一　一对多　多对多的交互通信； 
6.  UDP的首部开销小，只有８字节。

TCP 和 UDP 的区别：

1.  TCP 是可靠传输，UDP 是不可靠传输；
2.  TCP 面向连接，UDP 无连接；
3.  TCP 传输数据有序，UDP 不保证数据的有序性；
4.  TCP 不保存数据边界，UDP 保留数据边界；
5.  TCP 传输速度相对 UDP 较慢；
6.  TCP 有流量控制和拥塞控制，UDP 没有；
7.  TCP 是重量级协议，UDP 是轻量级协议；
8.  TCP 首部较长20字节，UDP 首部较短８字节；

基于 TCP 和 UDP 的常用协议：

HTTP、HTTPS、FTP、TELNET、SMTP（简单邮件传输协议）基于可靠的 TCP 协议。

DNS、DHCP、TFTP、SNMP（简单网络管理协议）、RIP基于不可靠的 UDP 协议。

TCP 和 UDP 的应用场景：

TCP 应用场景：效率要求较低，但对准确性要求相对较高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有 UDP 高。举几个例子：文件传输、接收邮件、远程登陆。

UDP 应用场景：效率要求相对较高，对准确性要求相对较低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信。

### 5. HTTP 1.0、1.1、2.0 各个版本的区别

HTTP/1.0

1996年5月，HTTP/1.0版本发布，为了提高系统的效率，HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

这种方式就好像我们打电话的时候，只能说一件事儿一样，说完之后就要挂断，想要说另外一件事儿的时候就要重新拨打电话。

 HTTP/1.0中浏览器与服务器只保持短暂的连接，连接无法复用。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。 

我们知道TCP连接的建立需要三次握手，是很耗费时间的一个过程。所以，HTTP/1.0版本的性能比较差。

补充： HTTP1.0 其实也可以强制开启长链接，例如接受`Connection: keep-alive` 这个字段，但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 

HTTP/1.1

为了解决HTTP/1.0存在的缺陷，HTTP/1.1于1999年诞生。相比较于HTTP/1.0来说，最主要的改进就是引入了持久连接。所谓的持久连接即TCP连接默认不关闭，可以被多个请求复用。

由于之前打一次电话只能说一件事儿，效率很低。后来人们提出一种想法，就是电话打完之后，先不直接挂断，而是持续一小段时间，这一小段时间内，如果还有事情沟通可以再次进行沟通。 

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。

HTTP/1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 

有了持久连接和管道，大大的提升了HTTP的效率。但是服务端还是顺序执行的，效率还有提升的空间。

HTTP/2

HTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 发布后的首个更新，主要基于 SPDY 协议。 

HTTP/2 为了解决HTTP/1.1中仍然存在的效率问题，HTTP/2 采用了多路复用。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP/2进行了二进制分帧，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。

也就是说，老板可以同时下达多个命令，员工也可以收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。A请求的两部分响应在组合到一起发给老板。 

而这个负责拆分、组装请求和二进制帧的一层就叫做二进制分帧层。

除此之外，还有一些其他的优化，比如做Header压缩、服务端推送等。

Header压缩就是压缩老板和员工之间的对话。

服务端推送就是员工事先把一些老板可能询问的事情提现发送到老板的手机（缓存）上。这样老板想要知道的时候就可以直接读取短信（缓存）了。

目前，主流的HTTP协议还是HTTP/1.1 和 HTTP/2。并且各大网站的HTTP/2的使用率也在逐年增加。

### 6. 在交互过程中如果数据传送完了，还不想断开连接怎么办？怎么维持？

在HTTP中响应体的connection字段指定为keep-alive：

```
connection:keep-alive
```

### 7. HTTP 如何实现长连接？在什么时候会超时？

通过在头部（请求头和响应头）设置connection:keep-alive，HTTP/1.0协议支持，但是默认关闭，从HTTP/1.1协议以后，连接默认都是长连接。

HTTP一般会有httpd守护线程，里面可以设置keep-alive timeout，当tcp连接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间。

TCP的keep-alive包含三个参数，支持在系统内核的net.ipv4里面设置：当TCP连接以后，闲置了tcp_keepalive_time，则会发生侦测包，如果没有收到对方的ACK，那么会每隔tcp_keepalive_intvl再发一次，直到发送了tcp_keepalive_probes，就会丢弃该连接。

（1）tcp_keepalive_intvl = 15

（2）tcp_keepalive_probes = 5

（3）tcp_keepalive_time = 1800

实际上，HTTP没有长短连接，只有TCP有，TCP长连接可以复用一个TCP连接来发起多次HTTP请求，这样可以减少资源消耗。

### 8. TCP如何保证有效传输以及拥塞控制原理

TCP是面向连接的、可靠的、传输层通信协议。

可靠体现在：有状态、可控制。

- 有状态是指TCP会确认发送了哪些报文，接收方收到了哪些报文，哪些没收到，保证数据包按序到达，不允许有差错。
- 可控制是指如果出现丢包或者网络状况不佳，则会调整自己的行为，减少发送的速度或重发。

所以上面能保证数据包的有效传输。

**拥塞控制原理：**

原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了。

主要有三种方法：

- 慢启动阈值+拥塞避免
- 快速重传
- 快速恢复

**慢启动阈值+拥塞避免**

对于拥塞控制，TCP主要维护两个核心状态：

- 拥塞窗口
- 慢启动阈值

在发送端使用拥塞窗口来控制发送窗口的大小。

然后采用一种比较保守的慢启动算法来慢慢适应这个网络，在开始传输的一段时间，发送端和接收端会首先通过三次握手建立连接，确定各自接收窗口的大小，然后初始化双方的拥塞窗口，接着每经过一轮TRR（收发时延），拥塞窗口大小翻倍，直到达到慢启动阈值。

然后开始进行拥塞避免，拥塞避免具体的做法就是之前每一轮RTT，拥塞窗口翻倍，现在每一轮加一个。

**快速重传**

在TCP传输过程中，如果发生了丢包，接收端就会发送之前重复ACK，比如第5个包丢了，6、7到达，然后接收端会为6、7发送第四个包的ACK，这个时候发送端收到了2个重复的ACK，意识到丢包了，就会马上进行重传，而不用得到RTO（（超时重传时间）。

选择性重传：报文首部可选性中加入SACK属性，通过left edge和right edge标志哪些包到了，然后重传没到的包。

**快速恢复**

如果发送端收到了3个重复的ACK，发现丢包，觉得现在网络状况已经到了拥塞状态，那么就会进入到快速恢复阶段：

- 会将拥塞阈值降低为拥塞窗口的一半
- 然后拥塞窗口大小变为拥塞阈值
- 接着拥塞窗口再进行线性增加，以适应网络状况

### 9. IPV4地址不够如何解决

目前主要有以下两种方式：

- NAT协议（Network Address Translation）
- IPV6

### 10. IP地址和MAC地址有什么区别？

简单来说，IP地址主要用来网络寻址用的，而MAC地址则是身份的唯一象征，但是MAC地址不具备寻址的功能。

### 11. TCP最大连接数限制

**如何标识一个TCP连接**

在确定最大连接数之前，先来看看系统如何标识一个tcp连接。

系统用一个四元组来唯一标识一个TCP连接：

```
{
	local_ip, 
	local_port,
	remote_ip,
	remote_port
}
```

**client最大TCP连接数**

client每次发起TCP连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他TCP连接共享。 TCP端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大TCP连接数为65535，这些连接可以连到不同的server ip。  

**server最大TCP连接数**

server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，  因此server端TCP连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大TCP连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，  最大TCP连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大TCP连接数约为2的48次方。 

**实际的TCP连接数**

上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发TCP连接数远不能达到理论上限。  在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个TCP连接都要占用一定内存，每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。在默认2.6内核配置下，经过试验，每个socket占用内存在15~20k之间。 

 影响一个socket占用内存的参数包括： rmem_max、wmem_max、tcp_rmem、tcp_wmem、tcp_mem、grep skbuff /proc/slabinfo。

 对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万是没问题的，国外Urban Airship公司在产品环境中已做到 50 万并发 。

在实际应用中，对大规模网络应用，还需要考虑C10K问题。 

### 12. GET请求中URL编码的意义

避免歧义。

考虑这样一个场景：name1=va&lue=e1，其中va&lue=e1是值，但是服务端可能会将其解析成两个键值对，这样就产生了歧义。

解决方案就是对参数进行URL编码。

### 13. 网络五层模型⭐⭐⭐⭐⭐

物理层

数据链路层：以太网协议→帧，MAC地址、ARP

网络层：IP协议、ARP协议、DNS

传输层：PORT、TCP\UDP

应用层

### 14. HTTP和HTTPS的区别

HTTP协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；

HTTPS是身披SSL（Secure Socket Layer）外壳的HTTP，运行在SSL之上，SSL运行在TCP之上，是添加了加密和认证机制的HTTP。

不同：

1. 端口不同，HTTP与HTTPS使用不同的连接方式，用的端口也不同，前者是80，后者是443；
2. 资源消耗不同，HTTPS通信由于加密解密消耗更多的资源；
3. 开销不同，HTTPS需要证书，而证书一般需要向认证机构购买。

HTTPS的加密机制是一种共享密钥加密并用的混合加密机制。

### 15. 对称加密和非对称加密的区别

对称密钥加密是指加密和解密使用的是同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发送给对方。

而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接受到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的密钥，所以可以保证安全性，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

### 16. 什么是SQL注入？举个例子

SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

**SQL注入攻击的总体思路**

（1）寻找SQL注入的位置

（2）判断服务器类型和后台数据库类型

（3）针对不同的服务器和数据库特点进行SQL注入攻击

**SQL注入攻击实例**

比如在登录界面，要求输入用户名密码，可以这样输入避免账户登录：

```
username="or 1 = 1"
password=""
```

**应对方法**

（1）参数绑定：使用预编译手段，绑定参数是最好的防止SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL参数而不是SQL命令被执行。

（2）使用正则表达式过滤传入的参数

### 17. 谈一谈XSS攻击？举个例子

XSS是一种经常出现在Web应用中的计算机安全漏洞，与SQL注入一起成为Web中最主流的攻击方式。

XSS是指恶意攻击者利用网站没有对用户提交的数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到Web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或对访问者进行病毒侵害的一种攻击方式。

**修复漏洞方针**

漏洞产生的根本原因：太相信用户提交的数据。

具体方案包括：

（1）将重要的cookie标记为http only，这样js就无法获取到cookie，能够有效防止XSS攻击。

（2）表单数据类型检测。

（3）对数据进行HTML Encode处理。

（4）过滤或移除特殊HTML标签，过滤JS事件标签。

### 18. 简单说一下每一层对应的网络协议有哪些？

**应用层**：HTTP（超文本传输协议）、TFP（文件传输协议）、SMTP（简单邮件传输协议）、SSH（安全外壳协议）、DHCP（动态主机配置协议）、TELNET（远程登录协议）

**传输层**：TCP（传输控制协议）、UDP（用户数据报文协议）

**网络层**：IP（网际协议）、ARP（地址转换协议）、RARP（反向地址转换协议）、ICMP（Internet 控制报文协议）、IGMP（Internet 组管理协议）、RIP（路由信息协议）、OSPF（分布式链路状态协议）、BGP（边界网关协议）

**数据链路层**：ARQ（自动重传请求协议）、CSMA/CD（停止等待协议）、PPP（点对点协议）

**物理层**：中继器、集线器、网线、HUB

### 19. ARP协议的工作原理

网络层的ARP协议完成了IP地址与物理地址的映射。

首先，每台主机都会在自己的ARP缓冲区建立一个ARP列表，以表示IP地址和MAC地址的对应关系。

当源主机需要将一个数据包发送到目的主机时，会首先检查自己的ARP列表中是否存在该IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址，如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。

此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址，网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致，如果不相同就忽略此数据包，如果相同，该主机首先会将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址，源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。

如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

### 20. TCP的主要特点是什么

TCP

S是面向连接的。

每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。

TCP提供可靠交付的服务，通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。

TCP提供全双工通信，TCP允许通信双方的应用进程在任何时候都能发送数据，TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据。

面向字节流，TCP中的流指的是流入进程或从进程流出的字节序列。面向字节流的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来数据仅仅看成是一连串无结构的字节流。

### 21. UDP的主要特点是什么

UDP是无连接的。

UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态。

UDP是面向报文的。

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。

UDP支持一对一、一对多、多对多的交互通信。

UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

### 22. TCP和UDP分别对应的常见应用层协议有哪些？

**TCP对应的应用层协议**

FTP：定义了文件传输协议，使用21端口。

Telnet：远程登录协议，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。

SMTP：简单邮件传送协议，用于发送邮件，使用25端口。

POP3：它和SMTP对应，POP3用于接收邮件，通常情况下POP3协议使用110端口。

HTTP：从Web服务器传输超文本到本地浏览器的传送协议。

**UDP对应的应用层协议**

DNS：用于域名解析服务，将域名地址转换为IP地址，DNS使用53号端口号。

SNMP：简单网络管理协议，使用161号端口号，用来管理网络设备，由于网络设备很多，无连接的服务就体现出其优势。

TFTP（Trival File Transfer Protocal）：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

### 23. 为什么TIME-WAIT状态必须等待2MSL的时间呢？

（1）为了保证A发送的最后一个ACK报文段能够到达B，这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对方已经发送的FIN+ACK报文段的确认，B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内（超时+1MSL）收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器，最后A和B都正常进入到CLOSED状态，如果A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段，这样，B就无法按照正常步骤进入CLOSED状态。

（2）防止已失效的连接请求报文段出现在本连接中，A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都在网络中消失，这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

### 24. 保活计时器的作用？

除时间等待计时器外，TCP还有一个保活计时器（keepalive timer）。

设想这样的场景：A与B建立了TCP连接，A崩了，应当有措施让B不再等待下去。

服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两个小时都没有收到客户端的数据，服务端就会发送一个探测报文段，以后每隔75秒发送一次，若连续发送10个探测报文段后仍然无客户端响应，服务端就认为客户端出现了故障，接着就关闭这个连接。

### 25. TCP协议是如何保证可靠传输的？

（1）数据包校验：目的是检测数据在传输过程中的任何变化，若检验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据。

（2）对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序，TCP将对失序数据进行重新排序，然后才交给应用层。

（3）丢弃重复数据

（4）应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常将推迟几分之一秒。

（5）超时重发

（6）流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的连接端只允许另一端发送接收端缓冲区能接纳的数据，这可以防止较快主机致使较慢主机缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

### 26. 谈谈你对停止等待协议的理解

停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到。

### 27. 谈谈你对ARQ协议的理解

**自动重传请求ARQ协议**

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。

**连续ARQ协议**

连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

### 28. 谈谈你对滑动窗口的理解

TCP利用滑动窗口实现流量控制。

滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。

TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

### 29. 谈谈你对流量控制的理解？

TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 30. 谈谈你对TCP拥塞控制的理解，使用了哪些算法？



### 31. 什么是黏包？

在进行Java NIO学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。

（1）TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；

（2）从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段。

基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。

接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。

### 32. TCP黏包是怎么产生的？

**发送方产生黏包**

采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。

**接收方产生黏包**

接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）。

### 33. 怎么解决拆包和黏包

分包机制一般有两个通用的解决方法：

（1）特殊字符控制

（2）在包头首都添加数据包的长度

如果使用netty的话，就有专门的编码器和解码器解决拆包和粘包问题了。

TIPS：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。

### 34. forward和redirect的区别？

forward和redirect代表了两种请求转发方式：直接转发和间接转发。

直接转发方式（Forward）：客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。

间接转发方式（Redirect）：实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。

### 35. HTTP方法有哪些？

GET：获取资源，当前网络中绝大部分使用的都是 GET。

HEAD：获取报文首部，和GET方法类似，但是不返回报文实体主体部分。

POST：传输实体主体。

PUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

PATCH：对资源进行部分修改。PUT也可以用于修改资源，但是只能完全替代原始资源，PATCH允许部分修改。

OPTIONS：查询指定的URL支持的方法。

CONNECT：要求在与代理服务器通信时建立隧道。使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

TRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器就会减1，当数值为0时就停止传输。通常不会使用TRACE，并且它容易受到XST攻击（Cross-Site Tracing，跨站追踪）。

DELETE：删除文件,与 PUT 功能相反，并且同样不带验证机制。

### 36. 在浏览器中输入URL地址到显示主页的过程？

（1）DNS解析：浏览器查询DNS，获取域名对应的IP地址：具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；

（2）TCP连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；

（3）发送HTTP请求：TCP连接建立起来后，浏览器向服务器发送HTTP请求；

（4）服务器处理请求并返回HTTP报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；

（5）浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

（6）连接结束。

### 37. DNS解析具体步骤

（1）在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 

（2）如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 

（3）如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 

（4）如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 

（5）如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址([http://qq.com](https://link.zhihu.com/?target=http%3A//qq.com))给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找[http://qq.com](https://link.zhihu.com/?target=http%3A//qq.com)域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。 

6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用的是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 

从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。

### 38. DNS的解析过程

（1）主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。

（2）本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。

### 39. 谈谈你对域名缓存的了解

为了提到DNS查询效率，并减轻服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。

由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。  当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。 当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。

不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。 维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。  

### 40. 谈谈你对HTTP长连接和短连接的理解？分别应用于哪些场景？

 在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。 当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。

而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。 

Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 

### 41. HTTPS的工作过程

（1） 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了； 

（2） 服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构； 

（3）客户端收到网站的证书之后要做下面的事情：

- 验证证书的合法性；
- 如果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；
- 用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。

（4） 服务器接收到客户端传送来的信息，要做下面的事情： 

-  用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致； 
-  使用密钥加密消息。

（5） 如果计算法 hash 值一致，握手成功。 

### 42. HTTP和HTTPS的区别

1. 开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；
2. 资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；
3. 端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；
4. 安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全

### 43. HTTPS的优缺点

**优点**：

（1）使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

（2）HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性；

（3）HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

**缺点**：

（1）HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；

（2）HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

（3）SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；

（4）SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；

（5）HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。

### 44. 什么是数字签名

为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。 

### 45. 什么是数字证书

对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。 所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。

### 46. Cookie和Session的区别

HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是Session。

Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。

Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

### 47. UDP如何实现可靠传输

### 48. keep-alive和非keep-alive的区别















